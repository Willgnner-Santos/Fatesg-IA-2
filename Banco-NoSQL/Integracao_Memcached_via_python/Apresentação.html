<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memcached + Python: Integração e TTL</title>
    <!-- Carrega Tailwind CSS para estilização rápida e responsiva -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Configuração de fonte padrão -->
    <style>
        /* Chosen Palette: Light Minimalist - Background: F8F9FA (gray-50), Main: White, Accent: Indigo-600, Text: Gray-800 */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #F8F9FA; /* Fundo muito claro */
            color: #343A40; /* Texto escuro para alto contraste */
        }
        .slide-container {
            min-height: 85vh; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Sombra sutil */
        }
        .nav-button {
            transition: all 0.3s ease;
            border: 1px solid #E0E0E0; /* Borda clara */
        }
        .nav-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .code-block {
            background-color: #F3F4F6; /* Fundo claro para código */
            border-left: 4px solid #4F46E5; /* Destaque Índigo */
            color: #1F2937; /* Texto escuro */
            /* Fonte de código reduzida para 24px (1.5rem) para evitar rolagem lateral */
            font-size: 1.5rem; /* text-2xl (24px) */
        }
        /* Garantindo que o conteúdo de texto padrão seja 30px+ */
        .slide-content p, .slide-content li {
            font-size: 1.875rem; /* text-3xl (30px) */
        }
        .slide-content h2 {
             font-size: 2.25rem; /* text-4xl (36px) */
        }
    </style>
</head>
<body class="text-gray-800">
    <div id="app" class="p-4 sm:p-8 flex flex-col items-center justify-center min-h-screen">

        <!-- Header Fixo (48px / 60px) -->
        <header class="w-full max-w-5xl text-center py-4 mb-8 border-b border-gray-200">
            <h1 class="text-4xl sm:text-5xl font-extrabold text-indigo-600">Memcached & Python: Projeto de Integração</h1>
        </header>

        <!-- Container Principal dos Slides -->
        <div id="slides-container" class="w-full max-w-5xl bg-white p-6 sm:p-10 rounded-xl slide-container">
            <!-- Os slides serão injetados aqui -->
        </div>

        <!-- Barra de Navegação -->
        <div class="w-full max-w-5xl flex justify-center space-x-4 mt-8">
            <button id="prev-btn" class="nav-button px-6 py-2 bg-gray-200 text-gray-700 rounded-full font-semibold hover:bg-gray-300 disabled:opacity-50 transition duration-300 text-3xl">
                &larr; Anterior
            </button>
            <!-- Indicador (30px) -->
            <span id="slide-indicator" class="px-4 py-2 text-3xl font-mono text-indigo-600 bg-gray-100 rounded-full flex items-center"></span>
            <button id="next-btn" class="nav-button px-6 py-2 bg-indigo-600 text-white rounded-full font-semibold hover:bg-indigo-700 disabled:opacity-50 transition duration-300 text-3xl">
                Próximo &rarr;
            </button>
        </div>
    </div>

    <script>
        // --- Estrutura dos Slides (Todos os tamanhos foram ajustados para 30px/36px/48px) ---
        const slidesData = [
            // Slide 1: Título e Introdução
            {
                title: "Introdução: O Desafio da Performance",
                content: `
                    <div class="space-y-6">
                        <p class="text-3xl text-gray-600">Seja bem-vindo(a)! Esta é a nossa demonstração prática de caching.</p>
                        <h3 class="text-4xl font-bold text-indigo-600 mt-6">Grupo: Maria Clara Ribeiro Di Bragança e Frederico Lemes Rosa</h3>
                        <p class="text-3xl text-gray-500">O projeto foi realizado no ambiente **Ubuntu WSL**.</p>
                        <img src="https://placehold.co/600x200/4F46E5/FFFFFF?text=Python+%26+Memcached" alt="Ilustração Python e Memcached" class="rounded-lg shadow-md mx-auto mt-4">
                    </div>
                `
            },
            // Slide 2: O que é Memcached? (Conceitos)
            {
                title: "O que é Memcached? (Conceitos)",
                content: `
                    <div class="space-y-6">
                        <p class="text-4xl font-medium text-gray-700">É um sistema de **caching de objetos distribuído em memória (RAM)**. Atua como um intermediário super rápido para acelerar aplicações.</p>
                        <ul class="list-disc list-inside space-y-4 pl-4">
                            <li class="text-3xl"><strong class="text-green-600">In-Memory:</strong> Dados armazenados diretamente na RAM (velocidade máxima).</li>
                            <li class="text-3xl"><strong class="text-red-600">Não Persistente:</strong> Se o servidor reiniciar, os dados são perdidos. Não é um banco de dados principal.</li>
                            <li class="text-3xl"><strong class="text-yellow-700">Chave-Valor:</strong> Armazena e recupera dados de forma simples, como um dicionário.</li>
                        </ul>
                        <p class="text-3xl mt-4 text-gray-600">Usado para reduzir a carga de trabalho do banco de dados principal.</p>
                    </div>
                `
            },
            // Slide 3: Por que Usar (Cenário Comum)
            {
                title: "Por que Usar? O Fluxo de Cache",
                content: `
                    <div class="space-y-6">
                        <h3 class="text-4xl font-semibold text-indigo-600">Como o Cache Acelera a Aplicação?</h3>
                        <ol class="list-decimal list-inside space-y-4 text-3xl">
                            <li><strong class="text-yellow-700">Requisição:</strong> A aplicação (Python) precisa de um dado (ex: um perfil de usuário).</li>
                            <li><strong class="text-green-600">Verificação (HIT):</strong> Se o dado estiver no Memcached, ele é retornado **instantaneamente**.</li>
                            <li><strong class="text-red-600">Falha (MISS):</strong> Se o dado não estiver, a aplicação consulta o banco de dados lento.</li>
                            <li><strong class="text-indigo-600">Gravação:</strong> O resultado do banco é **gravado no Memcached** para a próxima requisição (com TTL).</li>
                        </ol>
                        <p class="text-3xl text-gray-500">O objetivo é maximizar os "HITs" no cache.</p>
                    </div>
                `
            },
            // Slide 4: Configuração no WSL (Passo a Passo I)
            {
                title: "Experiência Prática: Configuração no WSL",
                content: `
                    <div class="space-y-4">
                        <h3 class="text-4xl font-semibold text-indigo-600">Passo 1: Instalação e Ativação do Servidor</h3>
                        <table class="w-full text-left rounded-lg overflow-hidden border border-gray-200 text-3xl">
                            <thead class="bg-indigo-600 text-white">
                                <tr><th class="p-3">Ação</th><th class="p-3">Comando</th><th class="p-3">Explicação</th></tr>
                            </thead>
                            <tbody class="bg-white divide-y divide-gray-200">
                                <tr><td class="p-3 font-semibold">Instalar Servidor</td><td class="p-3 code-block"><code>sudo apt install memcached</code></td><td class="p-3 text-gray-700">Baixa o pacote do Memcached.</td></tr>
                                <tr><td class="p-3 font-semibold">Iniciar Serviço</td><td class="p-3 code-block"><code>sudo systemctl start memcached</code></td><td class="p-3 text-gray-700">Inicia o servidor na porta 11211.</td></tr>
                                <tr><td class="p-3 font-semibold">Verificar Status</td><td class="p-3 code-block"><code>ps aux | grep memcached</code></td><td class="p-3 text-gray-700">Comprovamos que estava 'active (running)'.</td></tr>
                            </tbody>
                        </table>
                        <p class="text-3xl text-gray-500 mt-4">O servidor fica rodando em background, aguardando conexões.</p>
                    </div>
                `
            },
            // Slide 5: Preparação do Python (Passo a Passo II)
            {
                title: "Experiência Prática: Preparação do Python",
                content: `
                    <div class="space-y-4">
                        <h3 class="text-4xl font-semibold text-indigo-600">Passo 2: O Cliente e o Erro Comum</h3>
                        <p class="text-3xl text-red-600">Enfrentamos o erro: <code>externally-managed-environment</code>.</p>
                        <p class="text-3xl text-gray-600"><strong>Solução:</strong> Isolamento via **Ambiente Virtual (VENV)**.</p>
                        <table class="w-full text-left rounded-lg overflow-hidden border border-gray-200 text-3xl">
                            <thead class="bg-indigo-600 text-white">
                                <tr><th class="p-3">Ação</th><th class="p-3">Comando</th><th class="p-3">Explicação</th></tr>
                            </thead>
                            <tbody class="bg-white divide-y divide-gray-200">
                                <tr><td class="p-3 font-semibold">Criar VENV</td><td class="p-3 code-block"><code>python3 -m venv .venv</code></td><td class="p-3 text-gray-700">Cria um ambiente isolado.</td></tr>
                                <tr><td class="p-3 font-semibold">Ativar VENV</td><td class="p-3 code-block"><code>source .venv/bin/activate</code></td><td class="p-3 text-gray-700">Permite usar o 'pip' do projeto.</td></tr>
                                <tr><td class="p-3 font-semibold">Instalar Cliente</td><td class="p-3 code-block"><code>pip install python-memcached</code></td><td class="p-3 text-gray-700">Instala a biblioteca para a comunicação Python.</td></tr>
                            </tbody>
                        </table>
                    </div>
                `
            },
            // Slide 6: Implementação: Código de Teste (TTL) (CONTEÚDO FINAL)
            {
                title: "Implementação: Código de Teste (TTL)",
                content: `
                    <div class="space-y-4">
                        <p class="text-3xl text-gray-600">Este é o código Python executado no WSL para comprovar o funcionamento do **TTL (Time To Live)**.</p>
                        <div class="code-block p-4 rounded-lg overflow-x-auto">
                            <pre class="text-2xl"><code>
# Nome(s) do(s) Aluno(s): Maria Clara Ribeiro Di Bragança e Frederico Lemes Rosa
# Objetivo: Comprovar o mecanismo de expiração automática (TTL) do Memcached.

<span class="text-red-700 font-bold">import memcache</span>
<span class="text-red-700 font-bold">import time</span>

# --- Configuração ---
# Conecta o cliente Python ao servidor Memcached rodando no localhost na porta 11211.
<span class="text-red-700 font-bold">mc = memcache.Client(['127.0.0.1:11211'], debug=0)</span>

chave_teste = "minha_chave_ttl"
valor_teste = "Valor com Time To Live"
ttl_segundos = 5    # Tempo de vida de 5 segundos

print("--- Teste de Integração Memcached e Python ---")

# 1. Armazena um valor com TTL de 5 segundos
print(f"\n1. Armazenando a chave '{chave_teste}' com TTL de {ttl_segundos} segundos...")
# A função set aceita o tempo de expiração como terceiro parâmetro.
<span class="text-red-700 font-bold">mc.set(chave_teste, valor_teste, ttl_segundos)</span>

# 2. Lê o valor imediatamente
print("2. Lendo o valor imediatamente (antes da expiração)...")
<span class="text-red-700 font-bold">valor_lido = mc.get(chave_teste)</span>

if valor_lido:
    # O .decode() converte o valor de bytes (retorno padrão) para string legível.
    print(f"   SUCESSO: Valor lido é '{valor_lido.decode()}'")
else:
    print("   ERRO: Valor não encontrado!")

# 3. Aguarda 6 segundos para simular a expiração (TTL: 5 segundos)
tempo_espera = ttl_segundos + 1
print(f"\n3. Aguardando {tempo_espera} segundos para simular a expiração...")
<span class="text-red-700 font-bold">time.sleep(tempo_espera)</span>

# 4. Verifica se o valor foi removido automaticamente
print("4. Verificando se o valor foi removido automaticamente (após a expiração)...")
<span class="text-red-700 font-bold">valor_expirado = mc.get(chave_teste)</span>

if valor_expirado is None:
    print("   SUCESSO: O valor foi removido (expirou) como esperado!")
else:
    print(f"   ERRO: O valor AINDA está presente: '{valor_expirado.decode()}'")

print("\n--- Fim do Teste ---")
                            </code></pre>
                        </div>
                    </div>
                `
            },
            // Slide 7: Resultado da Execução (Comprovação do TTL)
            {
                title: "O Foco: Expiração Automática (TTL)",
                content: `
                    <div class="space-y-4">
                        <p class="text-3xl text-gray-600">Este é o log gerado ao executar o script. A prova do TTL está na diferença entre as duas tentativas de leitura.</p>
                        <div class="code-block p-4 rounded-lg overflow-x-auto font-mono">
                            <pre class="text-2xl"><code>
--- Teste de Integração Memcached e Python ---

1. Armazenando a chave 'minha_chave_ttl' com TTL de 5 segundos...
2. Lendo o valor imediatamente (antes da expiração)...
   SUCESSO: Valor lido é 'Valor com Time To Live'

3. Aguardando 6 segundos para simular a expiração...

4. Verificando se o valor foi removido automaticamente (após a expiração)...
   SUCESSO: O valor foi removido (expirou) como esperado!

--- Fim do Teste ---
                            </code></pre>
                        </div>
                        <p class="text-4xl font-bold text-indigo-600">Resultado Chave: A segunda leitura (após 6s) retorna **Nulo (None)**. Isso valida o mecanismo de expiração automática do Memcached.</p>
                    </div>
                `
            },
            // Slide 8: Resumo Técnico e Conclusão
            {
                title: "Resumo Técnico e Conclusão",
                content: `
                    <div class="space-y-6">
                        <h3 class="text-4xl font-semibold text-indigo-600 mb-4">Comandos Chave da Integração</h3>
                        <table class="w-full text-left rounded-lg overflow-hidden border border-gray-200 text-3xl">
                            <thead class="bg-indigo-600 text-white">
                                <tr><th class="p-3">Comando</th><th class="p-3">Função</th></tr>
                            </thead>
                            <tbody class="bg-white divide-y divide-gray-200">
                                <tr><td class="p-3 font-semibold">mc.Client(['IP:PORT'])</td><td class="p-3 text-gray-700">Estabelece a conexão com o servidor Memcached.</td></tr>
                                <tr><td class="p-3 font-semibold">mc.set(chave, valor, TTL)</td><td class="p-3 text-gray-700">Grava o dado no cache. O TTL (5s) define o tempo de vida.</td></tr>
                                <tr><td class="p-3 font-semibold">mc.get(chave)</td><td class="p-3 text-gray-700">Lê o dado do cache. Retorna 'None' se expirado/não existir.</td></tr>
                                <tr><td class="p-3 font-semibold">time.sleep(segundos)</td><td class="p-3 text-gray-700">Pausa a execução para simular a expiração do TTL.</td></tr>
                            </tbody>
                        </table>
                        
                        <h3 class="text-5xl font-extrabold text-indigo-600 mt-8">O que Ganhamos:</h3>
                        <ul class="list-disc list-inside space-y-4 text-4xl">
                            <li><strong class="text-green-600">Performance Extrema:</strong> Redução drástica da latência de leitura.</li>
                            <li><strong class="text-green-600">Escalabilidade:</strong> O banco de dados aguenta mais carga, pois menos consultas chegam a ele.</li>
                            <li><strong class="text-green-600">Gestão de Dados:</strong> O mecanismo TTL garante a frescura (não-obsolescência) dos dados.</li>
                            <li><strong class="text-green-600">Simplicidade:</strong> A API Python é extremamente fácil de usar.</li>
                        </ul>
                        <p class="text-4xl font-semibold mt-8 text-gray-700">"O Memcached é essencial para qualquer aplicação que busca alta velocidade e eficiência."</p>
                    </div>
                `
            },
            // Slide 9: Aprofundamento (SET/GET/DELETE)
            {
                title: "Aprofundamento: SET, GET e DELETE",
                content: `
                    <div class="space-y-4">
                        <p class="text-3xl text-gray-600">Este script explora a manipulação básica de dados em cache: Criar, Atualizar e Remover.</p>
                        <div class="code-block p-4 rounded-lg overflow-x-auto">
                            <pre class="text-2xl"><code>
<span class="text-red-700 font-bold">import memcache</span>
chave_nova = "usuario_logado_123"
valor_cache = "Dados complexos de Sessao"

print("### 1. DEMONSTRAÇÃO DE SET (CRIAR E ATUALIZAR) ###")

# 1.1. SET Inicial (Criação)
<span class="text-red-700 font-bold">mc.set(chave_nova, valor_cache)</span>

# 1.2. GET para confirmar
<span class="text-red-700 font-bold">valor_lido = mc.get(chave_nova)</span> 
print(f"-> CRIADO: '{valor_lido.decode()}'")

# 1.3. SET de Atualização
novo_valor = "Dados complexos de Sessao ATUALIZADOS"
<span class="text-red-700 font-bold">mc.set(chave_nova, novo_valor)</span>
print("-> VALOR ATUALIZADO.")

# --- Bloco 3: DELETE (Remoção) ---
print("\n### 2. DEMONSTRAÇÃO DE DELETE ###")

# 2.1. DELETE
<span class="text-red-700 font-bold">resultado_delete = mc.delete(chave_nova)</span> 
print(f"-> DELETADO: {resultado_delete} (True = Sucesso)")

# 2.2. GET após delete
valor_apos_delete = mc.get(chave_nova)
if valor_apos_delete is None:
    print("-> SUCESSO: Chave não encontrada (None).")
else:
    print("-> ERRO: A chave ainda existe!")
                            </code></pre>
                        </div>
                    </div>
                `
            },
            // Slide 10: Aprofundamento (TTL Detalhado)
            {
                title: "Aprofundamento: TTL (Expiração em Tempo Real)",
                content: `
                    <div class="space-y-4">
                        <p class="text-3xl text-gray-600">O Memcached gerencia a remoção de chaves. Aqui, o SET com TTL de 3 segundos.</p>
                        <div class="code-block p-4 rounded-lg overflow-x-auto">
                            <pre class="text-2xl"><code>
<span class="text-red-700 font-bold">import time</span> # Necessário para a pausa (sleep)
chave_expiravel = "noticia_destaque"
ttl_segundos = 3
valor_expiravel = "Previsao do Tempo de Hoje"

print("### 3. DEMONSTRAÇÃO DE TTL (EXPIRAÇÃO AUTOMÁTICA) ###")

# 3.1. SET com TTL (o parâmetro time=ttl_segundos é crucial)
<span class="text-red-700 font-bold">mc.set(chave_expiravel, valor_expiravel, time=ttl_segundos)</span>

# 3.2. GET Imediato (SUCESSO)
valor_antes = mc.get(chave_expiravel)
print(f"-> LIDO ANTES: '{valor_antes.decode()}'")

# 3.3. AGUARDANDO (Pausa forçada no script)
tempo_espera = ttl_segundos + 1
<span class="text-red-700 font-bold">time.sleep(tempo_espera)</span>
print(f"-> AGUARDOU {tempo_espera}s (O Memcached expirou a chave)")

# 3.4. GET após a Expiração (FALHA ESPERADA)
valor_depois = mc.get(chave_expiravel)

if valor_depois is None:
    print("-> SUCESSO TTL: Valor é None. A chave expirou.")
else:
    print("-> ERRO TTL: Valor AINDA existe.")

print("\n--- FIM DA DEMONSTRAÇÃO ---")
                            </code></pre>
                        </div>
                    </div>
                `
            },
            // Slide 11: Resultado do Aprofundamento (Index 10)
            {
                title: "Resultado: Comandos SET/DELETE/TTL",
                content: `
                    <div class="space-y-4">
                        <p class="text-3xl text-gray-600">A saída consolida as operações de manipulação de dados e a eficácia do TTL de 3 segundos.</p>
                        <div class="code-block p-4 rounded-lg overflow-x-auto font-mono">
                            <pre class="text-2xl"><code>
### 1. DEMONSTRAÇÃO DE SET (CRIAR E ATUALIZAR) ###
-> CRIADO: 'Dados complexos de Sessao'
-> VALOR ATUALIZADO.

### 2. DEMONSTRAÇÃO DE DELETE ###
-> DELETADO: 1 (True = Sucesso)
-> SUCESSO: Chave não encontrada (None).

### 3. DEMONSTRAÇÃO DE TTL (EXPIRAÇÃO AUTOMÁTICA) ###
-> LIDO ANTES: 'Previsao do Tempo de Hoje'
-> AGUARDOU 4s (O Memcached expirou a chave)
-> SUCESSO TTL: Valor é None. A chave expirou.

--- FIM DA DEMONSTRAÇÃO ---
                            </code></pre>
                        </div>
                        <p class="text-4xl font-bold text-indigo-600 mt-6">Conclusão: Demonstramos com sucesso a **atualização**, **remoção imediata** e **expiração automática** de dados no Memcached.</p>
                    </div>
                `
            },
            // Slide 12 (Index 11): Resumo dos Comandos Avançados
            {
                title: "Resumo: Comandos de Manipulação de Dados",
                content: `
                    <div class="space-y-6">
                        <h3 class="text-4xl font-semibold text-indigo-600 mb-4">Funções da Biblioteca <code>python-memcached</code></h3>
                        <table class="w-full text-left rounded-lg overflow-hidden border border-gray-200 text-3xl">
                            <thead class="bg-indigo-600 text-white">
                                <tr><th class="p-3">Comando Principal</th><th class="p-3">O que ele faz</th></tr>
                            </thead>
                            <tbody class="bg-white divide-y divide-gray-200">
                                <tr><td class="p-3 font-semibold">mc.set(chave, valor, TTL)</td><td class="p-3 text-gray-700">**Grava/Atualiza** um item no cache. O parâmetro opcional TTL define a expiração.</td></tr>
                                <tr><td class="p-3 font-semibold">mc.get(chave)</td><td class="p-3 text-gray-700">**Lê** o valor de uma chave. É a operação mais comum e rápida do cache.</td></tr>
                                <tr><td class="p-3 font-semibold">mc.delete(chave)</td><td class="p-3 text-gray-700">**Remove** uma chave imediatamente. Usado para forçar a atualização de um dado obsoleto.</td></tr>
                                <tr><td class="p-3 font-semibold">time.sleep(segundos)</td><td class="p-3 text-gray-700">(Módulo Python) Pausa o script, permitindo testar se o TTL do Memcached funcionou.</td></tr>
                            </tbody>
                        </table>
                        
                        <p class="text-4xl font-semibold mt-8 text-gray-700">Esses quatro comandos são a base para gerenciar qualquer cache distribuído.</p>
                    </div>
                `
            },
            // Slide 13 (Index 12): Conclusão Final
            {
                title: "Conclusão Final: Vantagens e Aprendizado",
                content: `
                    <div class="space-y-8">
                        <h3 class="text-5xl font-extrabold text-indigo-600">Por Que Memcached Vence?</h3>
                        <ul class="list-disc list-inside space-y-4 text-4xl ml-6">
                            <li class="font-bold text-gray-700"><span class="text-green-600">Velocidade Máxima:</span> Acesso a dados em milissegundos, diretamente da RAM.</li>
                            <li class="font-bold text-gray-700"><span class="text-green-600">Alívio de Carga:</span> Protege o Banco de Dados contra sobrecarga de leituras repetitivas.</li>
                            <li class="font-bold text-gray-700"><span class="text-green-600">Inteligência de Tempo:</span> O TTL automatiza a limpeza, garantindo dados sempre frescos.</li>
                        </ul>

                        <hr class="border-t-2 border-gray-200 mx-auto w-3/4">

                        <h3 class="text-5xl font-extrabold text-indigo-600 pt-4">Nosso Aprendizado Prático</h3>
                        <ul class="list-disc list-inside space-y-4 text-4xl ml-6">
                            <li class="text-gray-700">Dominamos a **integração real** (servidor no WSL + cliente Python).</li>
                            <li class="text-gray-700">Aprendemos a importância de isolar projetos com **Ambientes Virtuais (VENV)**.</li>
                            <li class="text-gray-700">Comprovamos visualmente o ciclo de vida do cache: **Gravar, Ler, Expirar e Remover**.</li>
                        </ul>
                        <p class="text-4xl font-semibold mt-8 text-indigo-600 text-center">O cache não é apenas velocidade, é **inteligência de recurso**.</p>
                    </div>
                `
            }
        ];

        let currentSlide = 0;
        const slidesContainer = document.getElementById('slides-container');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const indicator = document.getElementById('slide-indicator');

        function renderSlide(index) {
            // Limpa o script do slide anterior (se houver)
            const oldScript = document.getElementById('slide-script');
            if (oldScript) {
                oldScript.remove();
            }
            
            const slide = slidesData[index];
            
            // Renderiza o título do slide (tamanho 36px)
            let htmlContent = `<h2 class="text-4xl font-bold mb-8 text-center text-indigo-600">${slide.title}</h2>`;
            
            // Renderiza o conteúdo (usando o JS para gerenciar classes de tamanho)
            htmlContent += `<div class="slide-content">${slide.content}</div>`;
            
            slidesContainer.innerHTML = htmlContent;


            // Executa o script JS específico do slide (para interatividade)
            if (slide.script) {
                const scriptEl = document.createElement('script');
                scriptEl.id = 'slide-script';
                scriptEl.textContent = '('.concat(slide.script.toString()).concat(')()');
                document.body.appendChild(scriptEl);
            }

            // Atualiza botões e indicador
            prevBtn.disabled = index === 0;
            nextBtn.disabled = index === slidesData.length - 1;
            indicator.textContent = "".concat(index + 1).concat(" / ").concat(slidesData.length);

            currentSlide = index;
        }

        // --- Navegação ---
        prevBtn.addEventListener('click', () => {
            if (currentSlide > 0) {
                renderSlide(currentSlide - 1);
            }
        });

        nextBtn.addEventListener('click', () => {
            if (currentSlide < slidesData.length - 1) {
                renderSlide(currentSlide + 1);
            }
        });

        // Inicia a apresentação no primeiro slide
        document.addEventListener('DOMContentLoaded', () => {
            renderSlide(0);
        });

        // Adiciona navegação por setas do teclado (melhorando a interatividade)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' && currentSlide < slidesData.length - 1) {
                renderSlide(currentSlide + 1);
            } else if (e.key === 'ArrowLeft' && currentSlide > 0) {
                renderSlide(currentSlide - 1);
            }
        });

    </script>
</body>
</html>
