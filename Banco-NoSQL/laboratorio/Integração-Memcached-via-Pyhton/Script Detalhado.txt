import memcache

# --- Bloco 1: Conexão e Definições ---
# Conecta o cliente Python ao servidor Memcached rodando no localhost (127.0.0.1) na porta 11211.
# O debug=0 evita que mensagens de erro detalhadas sejam impressas, mantendo a saída limpa.
mc = memcache.Client(['127.0.0.1:11211'], debug=0)

chave_nova = "usuario_logado_123"
valor_cache = "Dados complexos de Sessao"
chave_expiravel = "noticia_destaque"
valor_expiravel = "Previsao do Tempo de Hoje"
ttl_segundos = 3

print("--- DEMONSTRAÇÃO DETALHADA DO MEMCACHED ---")
print(f"Status do Servidor: Conectado em 127.0.0.1:11211\n")


# --- Bloco 2: O Comando SET (Criação e Atualização) ---
print("### 1. DEMONSTRAÇÃO DE SET (CRIAR E ATUALIZAR) ###")

# A. Set Inicial (Criação)
print(f"1.1. SET: Criando a chave '{chave_nova}'...")
resultado_set = mc.set(chave_nova, valor_cache)
print(f"   Resultado do SET: {resultado_set} (True = Sucesso)")

# B. Get para confirmar a criação
print(f"1.2. GET: Lendo a chave recém-criada...")
valor_lido = mc.get(chave_nova)
print(f"   Valor lido: '{valor_lido.decode()}'\n")

# C. Set de Atualização
novo_valor = "Dados complexos de Sessao ATUALIZADOS"
print(f"1.3. SET: Atualizando a chave '{chave_nova}' com um novo valor...")
mc.set(chave_nova, novo_valor)

# D. Get para confirmar a atualização
print(f"1.4. GET: Lendo o valor após a atualização...")
valor_atualizado = mc.get(chave_nova)
print(f"   Valor lido: '{valor_atualizado.decode()}' (Confirma a atualização!)\n")


# --- Bloco 3: O Comando DELETE (Remoção) ---
print("### 2. DEMONSTRAÇÃO DE DELETE ###")

# A. Delete
print(f"2.1. DELETE: Removendo a chave '{chave_nova}'...")
resultado_delete = mc.delete(chave_nova)
print(f"   Resultado do DELETE: {resultado_delete} (True = Sucesso)")

# B. Get após o delete
print(f"2.2. GET: Tentando ler a chave após a remoção...")
valor_apos_delete = mc.get(chave_nova)

if valor_apos_delete is None:
    print("   SUCESSO: Valor não encontrado (None). A chave foi removida.")
else:
    print("   ERRO: A chave ainda existe! Valor lido:", valor_apos_delete.decode())
print("-" * 40)


# --- Bloco 4: O Comando SET com TTL (Time To Live) ---
print("### 3. DEMONSTRAÇÃO DE TTL (EXPIRAÇÃO AUTOMÁTICA) ###")
import time # Importa a biblioteca time para a função sleep

# A. Set com TTL
print(f"3.1. SET com TTL: Armazenando a chave '{chave_expiravel}' por {ttl_segundos} segundos...")
mc.set(chave_expiravel, valor_expiravel, time=ttl_segundos)

# B. Get Imediato
valor_antes = mc.get(chave_expiravel)
print(f"3.2. GET Imediato: Valor lido: '{valor_antes.decode()}'")

# C. Aguarda a Expiração (TTL + 1 segundo)
tempo_espera = ttl_segundos + 1
print(f"3.3. AGUARDANDO: {tempo_espera} segundos para garantir a expiração...")
time.sleep(tempo_espera)

# D. Get após a Expiração
valor_depois = mc.get(chave_expiravel)

if valor_depois is None:
    print("3.4. GET Expirado: SU-CES-SO! Valor é None. O Memcached removeu a chave automaticamente.")
else:
    print(f"3.4. GET Expirado: ERRO! Valor AINDA existe: {valor_depois.decode()}")

print("\n--- FIM DA DEMONSTRAÇÃO ---")